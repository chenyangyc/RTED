{"function_name": "_format_task_params_to_tags", "function_content": "def _format_task_params_to_tags(self, task):\n    params = []\n    for key, value in task.params.items():\n        params.append('{key}:{value}'.format(key=key, value=value))\n    return params\n", "function_parameter": "(self, task)", "called_function_name": "", "called_function_parameter": "", "called_arguments": "", "user_prompt": "The function `_format_task_params_to_tags` is the last function in a function call chain (`_test_prune_done_tasks -> add_task -> set_status -> update_metrics -> handle_task_done -> _format_task_params_to_tags`). There is a `TypeError` in this function:\n```python\ndef _format_task_params_to_tags(self, task):\n    params = []\n    for key, value in task.params.items():\n        params.append('{key}:{value}'.format(key=key, value=value))\n    return params\n\n```\n\nPlease infer the type, fields, methods, and built-in characteristics of each parameter based on its usage within the function `_format_task_params_to_tags` to trigger the TypeError. Provide the result in JSON format. Please only output the JSON result without any additional explanations or comments.", "llm_output": "```json\n{\n  \"task\": {\n    \"type\": \"class\",\n    \"fields\": {\n      \"params\": {\n        \"type\": \"dict\",\n        \"fields\": {},\n        \"methods\": [\"items\"],\n        \"built-in\": [\"__getitem__\"]\n      }\n    },\n    \"methods\": [],\n    \"built-in\": []\n  }\n}\n```"}
{"function_name": "handle_task_done", "function_content": "def handle_task_done(self, task):\n    if task.time_running is None:\n        return\n    title = 'Luigi: A task has been completed!'\n    text = 'A task has completed in the pipeline named: {name}'.format(name\n        =task.family)\n    tags = ['task_name:{name}'.format(name=task.family)\n        ] + self._format_task_params_to_tags(task)\n    time_elapse = task.updated - task.time_running\n    self._send_increment('task.done', tags=tags)\n    self._send_gauge('task.execution_time', time_elapse, tags=tags)\n    event_tags = tags + ['task_state:DONE']\n    self._send_event(title=title, text=text, tags=event_tags, alert_type=\n        'info', priority='low')\n", "function_parameter": "(self, task)", "called_function_name": "_format_task_params_to_tags", "called_function_parameter": "(self, task)", "called_arguments": "(task)", "user_prompt": "The function `handle_task_done` in the call chain is as below, it calls the `_format_task_params_to_tags` function:\n```python\ndef handle_task_done(self, task):\n    if task.time_running is None:\n        return\n    title = 'Luigi: A task has been completed!'\n    text = 'A task has completed in the pipeline named: {name}'.format(name\n        =task.family)\n    tags = ['task_name:{name}'.format(name=task.family)\n        ] + self._format_task_params_to_tags(task)\n    time_elapse = task.updated - task.time_running\n    self._send_increment('task.done', tags=tags)\n    self._send_gauge('task.execution_time', time_elapse, tags=tags)\n    event_tags = tags + ['task_state:DONE']\n    self._send_event(title=title, text=text, tags=event_tags, alert_type=\n        'info', priority='low')\n\n```\nYou are provided with type information for the arguments of the called function. Use this as backward-flow type information to guide your inference in the caller.\nFunction being called: `_format_task_params_to_tags`.\n\nArguments defined in this called function: `(self, task)`.\nArguments passed to this called function: `(task)`.\nThe function belongs to class `DatadogMetricsCollector`.\nThe constructor of the class is:\n```python\ndef __init__(self, *args, **kwargs):\n    self._config = datadog(**kwargs)\n    initialize(api_key=self._config.api_key, app_key=self._config.app_key,\n        statsd_host=self._config.statsd_host, statsd_port=self._config.\n        statsd_port)\n\n```\n\n\nKnown type information for this called function's parameters:\n```json\n{\n  \"task\": {\n    \"type\": \"class\",\n    \"fields\": {\n      \"params\": {\n        \"type\": \"dict\",\n        \"fields\": {},\n        \"methods\": [\"items\"],\n        \"built-in\": [\"__getitem__\"]\n      }\n    },\n    \"methods\": [],\n    \"built-in\": []\n  }\n}\n```\nPlease infer the type, fields, methods, and built-in characteristics of each parameter based on its usage within the function `handle_task_done`, and using any constraints from the callee if available. Provide the result in JSON format. Please only output the JSON result without any additional explanations or comments. If the constraints can not be satisfied, return \"Unable to satisfy!\" and summarize as required in the system prompt.", "llm_output": "```json\n{\n  \"task\": {\n    \"type\": \"class\",\n    \"fields\": {\n      \"params\": {\n        \"type\": \"dict\",\n        \"fields\": {},\n        \"methods\": [\"items\"],\n        \"built-in\": [\"__getitem__\"]\n      },\n      \"time_running\": {\n        \"type\": \"other\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"family\": {\n        \"type\": \"str\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"updated\": {\n        \"type\": \"other\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": [\"__sub__\"]\n      }\n    },\n    \"methods\": [],\n    \"built-in\": []\n  }\n}\n```"}
{"function_name": "update_metrics", "function_content": "def update_metrics(self, task, config):\n    if task.status == DISABLED:\n        self._metrics_collector.handle_task_disabled(task, config)\n    elif task.status == DONE:\n        self._metrics_collector.handle_task_done(task)\n    elif task.status == FAILED:\n        self._metrics_collector.handle_task_failed(task)\n", "function_parameter": "(self, task, config)", "called_function_name": "handle_task_done", "called_function_parameter": "(self, task)", "called_arguments": "(task)", "user_prompt": "The function `update_metrics` in the call chain is as below, it calls the `handle_task_done` function:\n```python\ndef update_metrics(self, task, config):\n    if task.status == DISABLED:\n        self._metrics_collector.handle_task_disabled(task, config)\n    elif task.status == DONE:\n        self._metrics_collector.handle_task_done(task)\n    elif task.status == FAILED:\n        self._metrics_collector.handle_task_failed(task)\n\n```\nYou are provided with type information for the arguments of the called function. Use this as backward-flow type information to guide your inference in the caller.\nFunction being called: `handle_task_done`.\n\nArguments defined in this called function: `(self, task)`.\nArguments passed to this called function: `(task)`.\nThe function belongs to class `SimpleTaskState`.\nThe constructor of the class is:\n```python\ndef __init__(self, state_path):\n    self._state_path = state_path\n    self._tasks = {}\n    self._status_tasks = collections.defaultdict(dict)\n    self._active_workers = {}\n    self._task_batchers = {}\n    self._metrics_collector = None\n\n```\n\n\nKnown type information for this called function's parameters:\n```json\n{\n  \"task\": {\n    \"type\": \"class\",\n    \"fields\": {\n      \"params\": {\n        \"type\": \"dict\",\n        \"fields\": {},\n        \"methods\": [\"items\"],\n        \"built-in\": [\"__getitem__\"]\n      },\n      \"time_running\": {\n        \"type\": \"other\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"family\": {\n        \"type\": \"str\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"updated\": {\n        \"type\": \"other\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": [\"__sub__\"]\n      }\n    },\n    \"methods\": [],\n    \"built-in\": []\n  }\n}\n```\nPlease infer the type, fields, methods, and built-in characteristics of each parameter based on its usage within the function `update_metrics`, and using any constraints from the callee if available. Provide the result in JSON format. Please only output the JSON result without any additional explanations or comments. If the constraints can not be satisfied, return \"Unable to satisfy!\" and summarize as required in the system prompt.", "llm_output": "```json\n{\n  \"task\": {\n    \"type\": \"class\",\n    \"fields\": {\n      \"params\": {\n        \"type\": \"dict\",\n        \"fields\": {},\n        \"methods\": [\"items\"],\n        \"built-in\": [\"__getitem__\"]\n      },\n      \"time_running\": {\n        \"type\": \"other\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"family\": {\n        \"type\": \"str\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"updated\": {\n        \"type\": \"other\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": [\"__sub__\"]\n      },\n      \"status\": {\n        \"type\": \"other\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      }\n    },\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"config\": {\n    \"type\": \"other\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  }\n}\n```"}
{"function_name": "set_status", "function_content": "def set_status(self, task, new_status, config=None):\n    if new_status == FAILED:\n        assert config is not None\n    if new_status == DISABLED and task.status in (RUNNING, BATCH_RUNNING):\n        return\n    remove_on_failure = task.batch_id is not None and not task.batchable\n    if task.status == DISABLED:\n        if new_status == DONE:\n            self.re_enable(task)\n        elif task.scheduler_disable_time is not None and new_status != DISABLED:\n            return\n    if (task.status == RUNNING and task.batch_id is not None and new_status !=\n        RUNNING):\n        for batch_task in self.get_batch_running_tasks(task.batch_id):\n            self.set_status(batch_task, new_status, config)\n            batch_task.batch_id = None\n        task.batch_id = None\n    if new_status == FAILED and task.status != DISABLED:\n        task.add_failure()\n        if task.has_excessive_failures():\n            task.scheduler_disable_time = time.time()\n            new_status = DISABLED\n            if not config.batch_emails:\n                notifications.send_error_email(\n                    'Luigi Scheduler: DISABLED {task} due to excessive failures'\n                    .format(task=task.id),\n                    '{task} failed {failures} times in the last {window} seconds, so it is being disabled for {persist} seconds'\n                    .format(failures=task.retry_policy.retry_count, task=\n                    task.id, window=task.retry_policy.disable_window,\n                    persist=config.disable_persist))\n    elif new_status == DISABLED:\n        task.scheduler_disable_time = None\n    if new_status != task.status:\n        self._status_tasks[task.status].pop(task.id)\n        self._status_tasks[new_status][task.id] = task\n        task.status = new_status\n        task.updated = time.time()\n        self.update_metrics(task, config)\n    if new_status == FAILED:\n        task.retry = time.time() + config.retry_delay\n        if remove_on_failure:\n            task.remove = time.time()\n", "function_parameter": "(self, task, new_status, config=None)", "called_function_name": "update_metrics", "called_function_parameter": "(self, task, config)", "called_arguments": "(task, config)", "user_prompt": "The function `set_status` in the call chain is as below, it calls the `update_metrics` function:\n```python\ndef set_status(self, task, new_status, config=None):\n    if new_status == FAILED:\n        assert config is not None\n    if new_status == DISABLED and task.status in (RUNNING, BATCH_RUNNING):\n        return\n    remove_on_failure = task.batch_id is not None and not task.batchable\n    if task.status == DISABLED:\n        if new_status == DONE:\n            self.re_enable(task)\n        elif task.scheduler_disable_time is not None and new_status != DISABLED:\n            return\n    if (task.status == RUNNING and task.batch_id is not None and new_status !=\n        RUNNING):\n        for batch_task in self.get_batch_running_tasks(task.batch_id):\n            self.set_status(batch_task, new_status, config)\n            batch_task.batch_id = None\n        task.batch_id = None\n    if new_status == FAILED and task.status != DISABLED:\n        task.add_failure()\n        if task.has_excessive_failures():\n            task.scheduler_disable_time = time.time()\n            new_status = DISABLED\n            if not config.batch_emails:\n                notifications.send_error_email(\n                    'Luigi Scheduler: DISABLED {task} due to excessive failures'\n                    .format(task=task.id),\n                    '{task} failed {failures} times in the last {window} seconds, so it is being disabled for {persist} seconds'\n                    .format(failures=task.retry_policy.retry_count, task=\n                    task.id, window=task.retry_policy.disable_window,\n                    persist=config.disable_persist))\n    elif new_status == DISABLED:\n        task.scheduler_disable_time = None\n    if new_status != task.status:\n        self._status_tasks[task.status].pop(task.id)\n        self._status_tasks[new_status][task.id] = task\n        task.status = new_status\n        task.updated = time.time()\n        self.update_metrics(task, config)\n    if new_status == FAILED:\n        task.retry = time.time() + config.retry_delay\n        if remove_on_failure:\n            task.remove = time.time()\n\n```\nYou are provided with type information for the arguments of the called function. Use this as backward-flow type information to guide your inference in the caller.\nFunction being called: `update_metrics`.\n\nArguments defined in this called function: `(self, task, config)`.\nArguments passed to this called function: `(task, config)`.\nThe function belongs to class `SimpleTaskState`.\nThe constructor of the class is:\n```python\ndef __init__(self, state_path):\n    self._state_path = state_path\n    self._tasks = {}\n    self._status_tasks = collections.defaultdict(dict)\n    self._active_workers = {}\n    self._task_batchers = {}\n    self._metrics_collector = None\n\n```\n\n\nKnown type information for this called function's parameters:\n```json\n{\n  \"task\": {\n    \"type\": \"class\",\n    \"fields\": {\n      \"params\": {\n        \"type\": \"dict\",\n        \"fields\": {},\n        \"methods\": [\"items\"],\n        \"built-in\": [\"__getitem__\"]\n      },\n      \"time_running\": {\n        \"type\": \"other\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"family\": {\n        \"type\": \"str\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"updated\": {\n        \"type\": \"other\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": [\"__sub__\"]\n      },\n      \"status\": {\n        \"type\": \"other\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      }\n    },\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"config\": {\n    \"type\": \"other\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  }\n}\n```\nPlease infer the type, fields, methods, and built-in characteristics of each parameter based on its usage within the function `set_status`, and using any constraints from the callee if available. Provide the result in JSON format. Please only output the JSON result without any additional explanations or comments. If the constraints can not be satisfied, return \"Unable to satisfy!\" and summarize as required in the system prompt.", "llm_output": "```json\n{\n  \"task\": {\n    \"type\": \"class\",\n    \"fields\": {\n      \"params\": {\n        \"type\": \"dict\",\n        \"fields\": {},\n        \"methods\": [\"items\"],\n        \"built-in\": [\"__getitem__\"]\n      },\n      \"time_running\": {\n        \"type\": \"other\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"family\": {\n        \"type\": \"str\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"updated\": {\n        \"type\": \"other\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": [\"__sub__\"]\n      },\n      \"status\": {\n        \"type\": \"other\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"batch_id\": {\n        \"type\": \"other\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"batchable\": {\n        \"type\": \"bool\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"scheduler_disable_time\": {\n        \"type\": \"other\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"id\": {\n        \"type\": \"str\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"retry_policy\": {\n        \"type\": \"class\",\n        \"fields\": {\n          \"retry_count\": {\n            \"type\": \"int\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          },\n          \"disable_window\": {\n            \"type\": \"int\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          }\n        },\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"retry\": {\n        \"type\": \"other\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"remove\": {\n        \"type\": \"other\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      }\n    },\n    \"methods\": [\"add_failure\", \"has_excessive_failures\"],\n    \"built-in\": []\n  },\n  \"new_status\": {\n    \"type\": \"other\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"config\": {\n    \"type\": \"class\",\n    \"fields\": {\n      \"batch_emails\": {\n        \"type\": \"bool\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"disable_persist\": {\n        \"type\": \"int\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"retry_delay\": {\n        \"type\": \"int\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      }\n    },\n    \"methods\": [],\n    \"built-in\": []\n  }\n}\n```"}
{"function_name": "add_task", "function_content": "@rpc_method()\ndef add_task(self, task_id=None, status=PENDING, runnable=True, deps=None,\n    new_deps=None, expl=None, resources=None, priority=0, family='', module\n    =None, params=None, param_visibilities=None, accepts_messages=False,\n    assistant=False, tracking_url=None, worker=None, batchable=None,\n    batch_id=None, retry_policy_dict=None, owners=None, **kwargs):\n    \"\"\"\n        * add task identified by task_id if it doesn't exist\n        * if deps is not None, update dependency list\n        * update status of task\n        * add additional workers/stakeholders\n        * update priority when needed\n        \"\"\"\n    assert worker is not None\n    worker_id = worker\n    worker = self._update_worker(worker_id)\n    resources = {} if resources is None else resources.copy()\n    if retry_policy_dict is None:\n        retry_policy_dict = {}\n    retry_policy = self._generate_retry_policy(retry_policy_dict)\n    if worker.enabled:\n        _default_task = self._make_task(task_id=task_id, status=PENDING,\n            deps=deps, resources=resources, priority=priority, family=\n            family, module=module, params=params, param_visibilities=\n            param_visibilities)\n    else:\n        _default_task = None\n    task = self._state.get_task(task_id, setdefault=_default_task)\n    if task is None or task.status != RUNNING and not worker.enabled:\n        return\n    if status == PENDING and task.status == DONE and time.time(\n        ) - task.updated < self._config.stable_done_cooldown_secs:\n        return\n    if not task.family:\n        task.family = family\n    if not getattr(task, 'module', None):\n        task.module = module\n    if not getattr(task, 'param_visibilities', None):\n        task.param_visibilities = _get_default(param_visibilities, {})\n    if not task.params:\n        task.set_params(params)\n    if batch_id is not None:\n        task.batch_id = batch_id\n    if status == RUNNING and not task.worker_running:\n        task.worker_running = worker_id\n        if batch_id:\n            batch_tasks = self._state.get_batch_running_tasks(batch_id)\n            task.resources_running = batch_tasks[0].resources_running.copy()\n        task.time_running = time.time()\n    if accepts_messages is not None:\n        task.accepts_messages = accepts_messages\n    if tracking_url is not None or task.status != RUNNING:\n        task.tracking_url = tracking_url\n        if task.batch_id is not None:\n            for batch_task in self._state.get_batch_running_tasks(task.batch_id\n                ):\n                batch_task.tracking_url = tracking_url\n    if batchable is not None:\n        task.batchable = batchable\n    if task.remove is not None:\n        task.remove = None\n    if expl is not None:\n        task.expl = expl\n        if task.batch_id is not None:\n            for batch_task in self._state.get_batch_running_tasks(task.batch_id\n                ):\n                batch_task.expl = expl\n    task_is_not_running = task.status not in (RUNNING, BATCH_RUNNING)\n    task_started_a_run = status in (DONE, FAILED, RUNNING)\n    running_on_this_worker = task.worker_running == worker_id\n    if (task_is_not_running or task_started_a_run and\n        running_on_this_worker or new_deps):\n        if status != task.status or status == PENDING:\n            self._update_task_history(task, status)\n        self._state.set_status(task, PENDING if status == SUSPENDED else\n            status, self._config)\n    if status == FAILED and self._config.batch_emails:\n        batched_params, _ = self._state.get_batcher(worker_id, family)\n        if batched_params:\n            unbatched_params = {param: value for param, value in task.\n                params.items() if param not in batched_params}\n        else:\n            unbatched_params = task.params\n        try:\n            expl_raw = json.loads(expl)\n        except ValueError:\n            expl_raw = expl\n        self._email_batcher.add_failure(task.pretty_id, task.family,\n            unbatched_params, expl_raw, owners)\n        if task.status == DISABLED:\n            self._email_batcher.add_disable(task.pretty_id, task.family,\n                unbatched_params, owners)\n    if deps is not None:\n        task.deps = set(deps)\n    if new_deps is not None:\n        task.deps.update(new_deps)\n    if resources is not None:\n        task.resources = resources\n    if worker.enabled and not assistant:\n        task.stakeholders.add(worker_id)\n        for dep in (task.deps or []):\n            t = self._state.get_task(dep, setdefault=self._make_task(\n                task_id=dep, status=UNKNOWN, deps=None, priority=priority))\n            t.stakeholders.add(worker_id)\n    self._update_priority(task, priority, worker_id)\n    task.retry_policy = retry_policy\n    if runnable and status != FAILED and worker.enabled:\n        task.workers.add(worker_id)\n        self._state.get_worker(worker_id).tasks.add(task)\n        task.runnable = runnable\n", "function_parameter": "(self, task_id=None, status=PENDING, runnable=True, deps=None,\n    new_deps=None, expl=None, resources=None, priority=0, family='', module\n    =None, params=None, param_visibilities=None, accepts_messages=False,\n    assistant=False, tracking_url=None, worker=None, batchable=None,\n    batch_id=None, retry_policy_dict=None, owners=None, **kwargs)", "called_function_name": "set_status", "called_function_parameter": "(self, task, new_status, config=None)", "called_arguments": "(task, PENDING if status == SUSPENDED else\n            status, self._config)", "user_prompt": "The function `add_task` in the call chain is as below, it calls the `set_status` function:\n```python\n@rpc_method()\ndef add_task(self, task_id=None, status=PENDING, runnable=True, deps=None,\n    new_deps=None, expl=None, resources=None, priority=0, family='', module\n    =None, params=None, param_visibilities=None, accepts_messages=False,\n    assistant=False, tracking_url=None, worker=None, batchable=None,\n    batch_id=None, retry_policy_dict=None, owners=None, **kwargs):\n    \"\"\"\n        * add task identified by task_id if it doesn't exist\n        * if deps is not None, update dependency list\n        * update status of task\n        * add additional workers/stakeholders\n        * update priority when needed\n        \"\"\"\n    assert worker is not None\n    worker_id = worker\n    worker = self._update_worker(worker_id)\n    resources = {} if resources is None else resources.copy()\n    if retry_policy_dict is None:\n        retry_policy_dict = {}\n    retry_policy = self._generate_retry_policy(retry_policy_dict)\n    if worker.enabled:\n        _default_task = self._make_task(task_id=task_id, status=PENDING,\n            deps=deps, resources=resources, priority=priority, family=\n            family, module=module, params=params, param_visibilities=\n            param_visibilities)\n    else:\n        _default_task = None\n    task = self._state.get_task(task_id, setdefault=_default_task)\n    if task is None or task.status != RUNNING and not worker.enabled:\n        return\n    if status == PENDING and task.status == DONE and time.time(\n        ) - task.updated < self._config.stable_done_cooldown_secs:\n        return\n    if not task.family:\n        task.family = family\n    if not getattr(task, 'module', None):\n        task.module = module\n    if not getattr(task, 'param_visibilities', None):\n        task.param_visibilities = _get_default(param_visibilities, {})\n    if not task.params:\n        task.set_params(params)\n    if batch_id is not None:\n        task.batch_id = batch_id\n    if status == RUNNING and not task.worker_running:\n        task.worker_running = worker_id\n        if batch_id:\n            batch_tasks = self._state.get_batch_running_tasks(batch_id)\n            task.resources_running = batch_tasks[0].resources_running.copy()\n        task.time_running = time.time()\n    if accepts_messages is not None:\n        task.accepts_messages = accepts_messages\n    if tracking_url is not None or task.status != RUNNING:\n        task.tracking_url = tracking_url\n        if task.batch_id is not None:\n            for batch_task in self._state.get_batch_running_tasks(task.batch_id\n                ):\n                batch_task.tracking_url = tracking_url\n    if batchable is not None:\n        task.batchable = batchable\n    if task.remove is not None:\n        task.remove = None\n    if expl is not None:\n        task.expl = expl\n        if task.batch_id is not None:\n            for batch_task in self._state.get_batch_running_tasks(task.batch_id\n                ):\n                batch_task.expl = expl\n    task_is_not_running = task.status not in (RUNNING, BATCH_RUNNING)\n    task_started_a_run = status in (DONE, FAILED, RUNNING)\n    running_on_this_worker = task.worker_running == worker_id\n    if (task_is_not_running or task_started_a_run and\n        running_on_this_worker or new_deps):\n        if status != task.status or status == PENDING:\n            self._update_task_history(task, status)\n        self._state.set_status(task, PENDING if status == SUSPENDED else\n            status, self._config)\n    if status == FAILED and self._config.batch_emails:\n        batched_params, _ = self._state.get_batcher(worker_id, family)\n        if batched_params:\n            unbatched_params = {param: value for param, value in task.\n                params.items() if param not in batched_params}\n        else:\n            unbatched_params = task.params\n        try:\n            expl_raw = json.loads(expl)\n        except ValueError:\n            expl_raw = expl\n        self._email_batcher.add_failure(task.pretty_id, task.family,\n            unbatched_params, expl_raw, owners)\n        if task.status == DISABLED:\n            self._email_batcher.add_disable(task.pretty_id, task.family,\n                unbatched_params, owners)\n    if deps is not None:\n        task.deps = set(deps)\n    if new_deps is not None:\n        task.deps.update(new_deps)\n    if resources is not None:\n        task.resources = resources\n    if worker.enabled and not assistant:\n        task.stakeholders.add(worker_id)\n        for dep in (task.deps or []):\n            t = self._state.get_task(dep, setdefault=self._make_task(\n                task_id=dep, status=UNKNOWN, deps=None, priority=priority))\n            t.stakeholders.add(worker_id)\n    self._update_priority(task, priority, worker_id)\n    task.retry_policy = retry_policy\n    if runnable and status != FAILED and worker.enabled:\n        task.workers.add(worker_id)\n        self._state.get_worker(worker_id).tasks.add(task)\n        task.runnable = runnable\n\n```\nYou are provided with type information for the arguments of the called function. Use this as backward-flow type information to guide your inference in the caller.\nFunction being called: `set_status`.\n\nArguments defined in this called function: `(self, task, new_status, config=None)`.\nArguments passed to this called function: `(task, PENDING if status == SUSPENDED else\n            status, self._config)`.\nThe function belongs to class `Scheduler`.\nThe constructor of the class is:\n```python\ndef __init__(self, config=None, resources=None, task_history_impl=None, **\n    kwargs):\n    \"\"\"\n        Keyword Arguments:\n        :param config: an object of class \"scheduler\" or None (in which the global instance will be used)\n        :param resources: a dict of str->int constraints\n        :param task_history_impl: ignore config and use this object as the task history\n        \"\"\"\n    self._config = config or scheduler(**kwargs)\n    self._state = SimpleTaskState(self._config.state_path)\n    if task_history_impl:\n        self._task_history = task_history_impl\n    elif self._config.record_task_history:\n        from luigi import db_task_history\n        self._task_history = db_task_history.DbTaskHistory()\n    else:\n        self._task_history = history.NopHistory()\n    self._resources = resources or configuration.get_config().getintdict(\n        'resources')\n    self._make_task = functools.partial(Task, retry_policy=self._config.\n        _get_retry_policy())\n    self._worker_requests = {}\n    self._paused = False\n    if self._config.batch_emails:\n        self._email_batcher = BatchNotifier()\n    self._state._metrics_collector = MetricsCollectors.get(self._config.\n        metrics_collector, self._config.metrics_custom_import)\n\n```\n\n\nKnown type information for this called function's parameters:\n```json\n{\n  \"task\": {\n    \"type\": \"class\",\n    \"fields\": {\n      \"params\": {\n        \"type\": \"dict\",\n        \"fields\": {},\n        \"methods\": [\"items\"],\n        \"built-in\": [\"__getitem__\"]\n      },\n      \"time_running\": {\n        \"type\": \"other\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"family\": {\n        \"type\": \"str\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"updated\": {\n        \"type\": \"other\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": [\"__sub__\"]\n      },\n      \"status\": {\n        \"type\": \"other\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"batch_id\": {\n        \"type\": \"other\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"batchable\": {\n        \"type\": \"bool\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"scheduler_disable_time\": {\n        \"type\": \"other\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"id\": {\n        \"type\": \"str\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"retry_policy\": {\n        \"type\": \"class\",\n        \"fields\": {\n          \"retry_count\": {\n            \"type\": \"int\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          },\n          \"disable_window\": {\n            \"type\": \"int\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          }\n        },\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"retry\": {\n        \"type\": \"other\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"remove\": {\n        \"type\": \"other\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      }\n    },\n    \"methods\": [\"add_failure\", \"has_excessive_failures\"],\n    \"built-in\": []\n  },\n  \"new_status\": {\n    \"type\": \"other\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"config\": {\n    \"type\": \"class\",\n    \"fields\": {\n      \"batch_emails\": {\n        \"type\": \"bool\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"disable_persist\": {\n        \"type\": \"int\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"retry_delay\": {\n        \"type\": \"int\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      }\n    },\n    \"methods\": [],\n    \"built-in\": []\n  }\n}\n```\nPlease infer the type, fields, methods, and built-in characteristics of each parameter based on its usage within the function `add_task`, and using any constraints from the callee if available. Provide the result in JSON format. Please only output the JSON result without any additional explanations or comments. If the constraints can not be satisfied, return \"Unable to satisfy!\" and summarize as required in the system prompt.", "llm_output": "```json\n{\n  \"task_id\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"status\": {\n    \"type\": \"other\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"runnable\": {\n    \"type\": \"bool\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"deps\": {\n    \"type\": \"list\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"new_deps\": {\n    \"type\": \"list\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"expl\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"resources\": {\n    \"type\": \"dict\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": [\"copy\"]\n  },\n  \"priority\": {\n    \"type\": \"int\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"family\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"module\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"params\": {\n    \"type\": \"dict\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"param_visibilities\": {\n    \"type\": \"dict\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"accepts_messages\": {\n    \"type\": \"bool\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"assistant\": {\n    \"type\": \"bool\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"tracking_url\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"worker\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"batchable\": {\n    \"type\": \"bool\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"batch_id\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"retry_policy_dict\": {\n    \"type\": \"dict\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"owners\": {\n    \"type\": \"list\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"self\": {\n    \"type\": \"class\",\n    \"fields\": {\n      \"_config\": {\n        \"type\": \"class\",\n        \"fields\": {\n          \"batch_emails\": {\n            \"type\": \"bool\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          },\n          \"disable_persist\": {\n            \"type\": \"int\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          },\n          \"retry_delay\": {\n            \"type\": \"int\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          },\n          \"stable_done_cooldown_secs\": {\n            \"type\": \"int\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          }\n        },\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"_state\": {\n        \"type\": \"class\",\n        \"fields\": {\n          \"get_task\": {\n            \"type\": \"method\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          },\n          \"set_status\": {\n            \"type\": \"method\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          },\n          \"get_batch_running_tasks\": {\n            \"type\": \"method\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          },\n          \"get_batcher\": {\n            \"type\": \"method\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          },\n          \"get_worker\": {\n            \"type\": \"method\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          }\n        },\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"_make_task\": {\n        \"type\": \"method\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"_update_worker\": {\n        \"type\": \"method\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"_update_task_history\": {\n        \"type\": \"method\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"_update_priority\": {\n        \"type\": \"method\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"_email_batcher\": {\n        \"type\": \"class\",\n        \"fields\": {\n          \"add_failure\": {\n            \"type\": \"method\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          },\n          \"add_disable\": {\n            \"type\": \"method\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          }\n        },\n        \"methods\": [],\n        \"built-in\": []\n      }\n    },\n    \"methods\": [],\n    \"built-in\": []\n  }\n}\n```"}
