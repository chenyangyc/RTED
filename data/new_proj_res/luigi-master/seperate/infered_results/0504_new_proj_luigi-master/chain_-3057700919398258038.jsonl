{"function_name": "_email_disabled_reason", "function_content": "def _email_disabled_reason():\n    if email().format == 'none':\n        return \"email format is 'none'\"\n    elif email().force_send:\n        return None\n    elif sys.stdout.isatty():\n        return 'running from a tty'\n    else:\n        return None\n", "function_parameter": "()", "called_function_name": "", "called_function_parameter": "", "called_arguments": "", "user_prompt": "The function `_email_disabled_reason` needs to be analyzed is as below:\n```python\ndef _email_disabled_reason():\n    if email().format == 'none':\n        return \"email format is 'none'\"\n    elif email().force_send:\n        return None\n    elif sys.stdout.isatty():\n        return 'running from a tty'\n    else:\n        return None\n\n```\n\nPlease infer the type, fields, methods, and built-in characteristics of each parameter based on its usage within the function `_email_disabled_reason`, and using any constraints from the callee if available. Provide the result in JSON format. Please only output the JSON result without any additional explanations or comments.", "llm_output": "```json\n{\n  \"email\": {\n    \"type\": \"class\",\n    \"fields\": {\n      \"format\": {\n        \"type\": \"str\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"force_send\": {\n        \"type\": \"bool\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      }\n    },\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"sys.stdout\": {\n    \"type\": \"class\",\n    \"fields\": {},\n    \"methods\": [\"isatty\"],\n    \"built-in\": []\n  }\n}\n```"}
{"function_name": "send_email", "function_content": "def send_email(subject, message, sender, recipients, image_png=None):\n    \"\"\"\n    Decides whether to send notification. Notification is cancelled if there are\n    no recipients or if stdout is onto tty or if in debug mode.\n\n    Dispatches on config value email.method.  Default is 'smtp'.\n    \"\"\"\n    notifiers = {'ses': send_email_ses, 'sendgrid': send_email_sendgrid,\n        'smtp': send_email_smtp, 'sns': send_email_sns}\n    subject = _prefix(subject)\n    if not recipients or recipients == (None,):\n        return\n    if _email_disabled_reason():\n        logger.info('Not sending email to %r because %s', recipients,\n            _email_disabled_reason())\n        return\n    recipients_tmp = []\n    for r in recipients:\n        recipients_tmp.extend([a.strip() for a in r.split(',') if a.strip()])\n    recipients = recipients_tmp\n    logger.info('Sending email to %r', recipients)\n    email_sender = notifiers[email().method]\n    email_sender(sender, subject, message, recipients, image_png)\n", "function_parameter": "(subject, message, sender, recipients, image_png=None)", "called_function_name": "_email_disabled_reason", "called_function_parameter": "()", "called_arguments": "()", "user_prompt": "The function `send_email` needs to be analyzed is as below:\n```python\ndef send_email(subject, message, sender, recipients, image_png=None):\n    \"\"\"\n    Decides whether to send notification. Notification is cancelled if there are\n    no recipients or if stdout is onto tty or if in debug mode.\n\n    Dispatches on config value email.method.  Default is 'smtp'.\n    \"\"\"\n    notifiers = {'ses': send_email_ses, 'sendgrid': send_email_sendgrid,\n        'smtp': send_email_smtp, 'sns': send_email_sns}\n    subject = _prefix(subject)\n    if not recipients or recipients == (None,):\n        return\n    if _email_disabled_reason():\n        logger.info('Not sending email to %r because %s', recipients,\n            _email_disabled_reason())\n        return\n    recipients_tmp = []\n    for r in recipients:\n        recipients_tmp.extend([a.strip() for a in r.split(',') if a.strip()])\n    recipients = recipients_tmp\n    logger.info('Sending email to %r', recipients)\n    email_sender = notifiers[email().method]\n    email_sender(sender, subject, message, recipients, image_png)\n\n```\nYou are provided with type information for the arguments of the called function. Use this as backward-flow type information to guide your inference in the caller.\nFunction being called: `_email_disabled_reason`.\n\nArguments defined in this called function: `()`.\nArguments passed to this called function: `()`.\n\n\nKnown type information for this called function's parameters:\n```json\n{\n  \"email\": {\n    \"type\": \"class\",\n    \"fields\": {\n      \"format\": {\n        \"type\": \"str\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"force_send\": {\n        \"type\": \"bool\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      }\n    },\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"sys.stdout\": {\n    \"type\": \"class\",\n    \"fields\": {},\n    \"methods\": [\"isatty\"],\n    \"built-in\": []\n  }\n}\n```\nPlease infer the type, fields, methods, and built-in characteristics of each parameter based on its usage within the function `send_email`, and using any constraints from the callee if available. Provide the result in JSON format. Please only output the JSON result without any additional explanations or comments.", "llm_output": "```json\n{\n  \"subject\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"message\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"sender\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"recipients\": {\n    \"type\": \"tuple\",\n    \"fields\": {},\n    \"methods\": [\"split\"],\n    \"built-in\": [\"__iter__\"]\n  },\n  \"image_png\": {\n    \"type\": \"bytes\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  }\n}\n```"}
{"function_name": "send_error_email", "function_content": "def send_error_email(subject, message, additional_recipients=None):\n    \"\"\"\n    Sends an email to the configured error email, if it's configured.\n    \"\"\"\n    recipients = _email_recipients(additional_recipients)\n    sender = email().sender\n    send_email(subject=subject, message=message, sender=sender, recipients=\n        recipients)\n", "function_parameter": "(subject, message, additional_recipients=None)", "called_function_name": "send_email", "called_function_parameter": "(subject, message, sender, recipients, image_png=None)", "called_arguments": "(subject=subject, message=message, sender=sender, recipients=\n        recipients)", "user_prompt": "The function `send_error_email` needs to be analyzed is as below:\n```python\ndef send_error_email(subject, message, additional_recipients=None):\n    \"\"\"\n    Sends an email to the configured error email, if it's configured.\n    \"\"\"\n    recipients = _email_recipients(additional_recipients)\n    sender = email().sender\n    send_email(subject=subject, message=message, sender=sender, recipients=\n        recipients)\n\n```\nYou are provided with type information for the arguments of the called function. Use this as backward-flow type information to guide your inference in the caller.\nFunction being called: `send_email`.\n\nArguments defined in this called function: `(subject, message, sender, recipients, image_png=None)`.\nArguments passed to this called function: `(subject=subject, message=message, sender=sender, recipients=\n        recipients)`.\n\n\nKnown type information for this called function's parameters:\n```json\n{\n  \"subject\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"message\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"sender\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"recipients\": {\n    \"type\": \"tuple\",\n    \"fields\": {},\n    \"methods\": [\"split\"],\n    \"built-in\": [\"__iter__\"]\n  },\n  \"image_png\": {\n    \"type\": \"bytes\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  }\n}\n```\nPlease infer the type, fields, methods, and built-in characteristics of each parameter based on its usage within the function `send_error_email`, and using any constraints from the callee if available. Provide the result in JSON format. Please only output the JSON result without any additional explanations or comments.", "llm_output": "```json\n{\n  \"subject\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"message\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"additional_recipients\": {\n    \"type\": \"tuple\",\n    \"fields\": {},\n    \"methods\": [\"split\"],\n    \"built-in\": [\"__iter__\"]\n  }\n}\n```"}
{"function_name": "set_status", "function_content": "def set_status(self, task, new_status, config=None):\n    if new_status == FAILED:\n        assert config is not None\n    if new_status == DISABLED and task.status in (RUNNING, BATCH_RUNNING):\n        return\n    remove_on_failure = task.batch_id is not None and not task.batchable\n    if task.status == DISABLED:\n        if new_status == DONE:\n            self.re_enable(task)\n        elif task.scheduler_disable_time is not None and new_status != DISABLED:\n            return\n    if (task.status == RUNNING and task.batch_id is not None and new_status !=\n        RUNNING):\n        for batch_task in self.get_batch_running_tasks(task.batch_id):\n            self.set_status(batch_task, new_status, config)\n            batch_task.batch_id = None\n        task.batch_id = None\n    if new_status == FAILED and task.status != DISABLED:\n        task.add_failure()\n        if task.has_excessive_failures():\n            task.scheduler_disable_time = time.time()\n            new_status = DISABLED\n            if not config.batch_emails:\n                notifications.send_error_email(\n                    'Luigi Scheduler: DISABLED {task} due to excessive failures'\n                    .format(task=task.id),\n                    '{task} failed {failures} times in the last {window} seconds, so it is being disabled for {persist} seconds'\n                    .format(failures=task.retry_policy.retry_count, task=\n                    task.id, window=task.retry_policy.disable_window,\n                    persist=config.disable_persist))\n    elif new_status == DISABLED:\n        task.scheduler_disable_time = None\n    if new_status != task.status:\n        self._status_tasks[task.status].pop(task.id)\n        self._status_tasks[new_status][task.id] = task\n        task.status = new_status\n        task.updated = time.time()\n        self.update_metrics(task, config)\n    if new_status == FAILED:\n        task.retry = time.time() + config.retry_delay\n        if remove_on_failure:\n            task.remove = time.time()\n", "function_parameter": "(self, task, new_status, config=None)", "called_function_name": "send_error_email", "called_function_parameter": "(subject, message, additional_recipients=None)", "called_arguments": "(\n                    'Luigi Scheduler: DISABLED {task} due to excessive failures'\n                    .format(task=task.id),\n                    '{task} failed {failures} times in the last {window} seconds, so it is being disabled for {persist} seconds'\n                    .format(failures=task.retry_policy.retry_count, task=\n                    task.id, window=task.retry_policy.disable_window,\n                    persist=config.disable_persist))", "user_prompt": "The function `set_status` needs to be analyzed is as below:\n```python\ndef set_status(self, task, new_status, config=None):\n    if new_status == FAILED:\n        assert config is not None\n    if new_status == DISABLED and task.status in (RUNNING, BATCH_RUNNING):\n        return\n    remove_on_failure = task.batch_id is not None and not task.batchable\n    if task.status == DISABLED:\n        if new_status == DONE:\n            self.re_enable(task)\n        elif task.scheduler_disable_time is not None and new_status != DISABLED:\n            return\n    if (task.status == RUNNING and task.batch_id is not None and new_status !=\n        RUNNING):\n        for batch_task in self.get_batch_running_tasks(task.batch_id):\n            self.set_status(batch_task, new_status, config)\n            batch_task.batch_id = None\n        task.batch_id = None\n    if new_status == FAILED and task.status != DISABLED:\n        task.add_failure()\n        if task.has_excessive_failures():\n            task.scheduler_disable_time = time.time()\n            new_status = DISABLED\n            if not config.batch_emails:\n                notifications.send_error_email(\n                    'Luigi Scheduler: DISABLED {task} due to excessive failures'\n                    .format(task=task.id),\n                    '{task} failed {failures} times in the last {window} seconds, so it is being disabled for {persist} seconds'\n                    .format(failures=task.retry_policy.retry_count, task=\n                    task.id, window=task.retry_policy.disable_window,\n                    persist=config.disable_persist))\n    elif new_status == DISABLED:\n        task.scheduler_disable_time = None\n    if new_status != task.status:\n        self._status_tasks[task.status].pop(task.id)\n        self._status_tasks[new_status][task.id] = task\n        task.status = new_status\n        task.updated = time.time()\n        self.update_metrics(task, config)\n    if new_status == FAILED:\n        task.retry = time.time() + config.retry_delay\n        if remove_on_failure:\n            task.remove = time.time()\n\n```\nYou are provided with type information for the arguments of the called function. Use this as backward-flow type information to guide your inference in the caller.\nFunction being called: `send_error_email`.\n\nArguments defined in this called function: `(subject, message, additional_recipients=None)`.\nArguments passed to this called function: `(\n                    'Luigi Scheduler: DISABLED {task} due to excessive failures'\n                    .format(task=task.id),\n                    '{task} failed {failures} times in the last {window} seconds, so it is being disabled for {persist} seconds'\n                    .format(failures=task.retry_policy.retry_count, task=\n                    task.id, window=task.retry_policy.disable_window,\n                    persist=config.disable_persist))`.\nThe function belongs to class `SimpleTaskState`.\nThe constructor of the class is:\n```python\ndef __init__(self, state_path):\n    self._state_path = state_path\n    self._tasks = {}\n    self._status_tasks = collections.defaultdict(dict)\n    self._active_workers = {}\n    self._task_batchers = {}\n    self._metrics_collector = None\n\n```\n\n\nKnown type information for this called function's parameters:\n```json\n{\n  \"subject\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"message\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"additional_recipients\": {\n    \"type\": \"tuple\",\n    \"fields\": {},\n    \"methods\": [\"split\"],\n    \"built-in\": [\"__iter__\"]\n  }\n}\n```\nPlease infer the type, fields, methods, and built-in characteristics of each parameter based on its usage within the function `set_status`, and using any constraints from the callee if available. Provide the result in JSON format. Please only output the JSON result without any additional explanations or comments.", "llm_output": "```json\n{\n  \"self\": {\n    \"type\": \"class\",\n    \"fields\": {\n      \"_state_path\": {\n        \"type\": \"str\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"_tasks\": {\n        \"type\": \"dict\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": [\"__getitem__\", \"__setitem__\"]\n      },\n      \"_status_tasks\": {\n        \"type\": \"collections.defaultdict\",\n        \"fields\": {},\n        \"methods\": [\"pop\"],\n        \"built-in\": [\"__getitem__\", \"__setitem__\"]\n      },\n      \"_active_workers\": {\n        \"type\": \"dict\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": [\"__getitem__\", \"__setitem__\"]\n      },\n      \"_task_batchers\": {\n        \"type\": \"dict\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": [\"__getitem__\", \"__setitem__\"]\n      },\n      \"_metrics_collector\": {\n        \"type\": \"NoneType\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      }\n    },\n    \"methods\": [\"get_batch_running_tasks\", \"re_enable\", \"update_metrics\"],\n    \"built-in\": []\n  },\n  \"task\": {\n    \"type\": \"class\",\n    \"fields\": {\n      \"status\": {\n        \"type\": \"str\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"batch_id\": {\n        \"type\": \"NoneType\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"batchable\": {\n        \"type\": \"bool\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"scheduler_disable_time\": {\n        \"type\": \"float\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"id\": {\n        \"type\": \"str\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"retry_policy\": {\n        \"type\": \"class\",\n        \"fields\": {\n          \"retry_count\": {\n            \"type\": \"int\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          },\n          \"disable_window\": {\n            \"type\": \"int\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          }\n        },\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"updated\": {\n        \"type\": \"float\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"retry\": {\n        \"type\": \"float\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"remove\": {\n        \"type\": \"float\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      }\n    },\n    \"methods\": [\"add_failure\", \"has_excessive_failures\"],\n    \"built-in\": []\n  },\n  \"new_status\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"config\": {\n    \"type\": \"class\",\n    \"fields\": {\n      \"batch_emails\": {\n        \"type\": \"bool\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"disable_persist\": {\n        \"type\": \"int\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"retry_delay\": {\n        \"type\": \"int\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      }\n    },\n    \"methods\": [],\n    \"built-in\": []\n  }\n}\n```"}
{"function_name": "add_task", "function_content": "@rpc_method()\ndef add_task(self, task_id=None, status=PENDING, runnable=True, deps=None,\n    new_deps=None, expl=None, resources=None, priority=0, family='', module\n    =None, params=None, param_visibilities=None, accepts_messages=False,\n    assistant=False, tracking_url=None, worker=None, batchable=None,\n    batch_id=None, retry_policy_dict=None, owners=None, **kwargs):\n    \"\"\"\n        * add task identified by task_id if it doesn't exist\n        * if deps is not None, update dependency list\n        * update status of task\n        * add additional workers/stakeholders\n        * update priority when needed\n        \"\"\"\n    assert worker is not None\n    worker_id = worker\n    worker = self._update_worker(worker_id)\n    resources = {} if resources is None else resources.copy()\n    if retry_policy_dict is None:\n        retry_policy_dict = {}\n    retry_policy = self._generate_retry_policy(retry_policy_dict)\n    if worker.enabled:\n        _default_task = self._make_task(task_id=task_id, status=PENDING,\n            deps=deps, resources=resources, priority=priority, family=\n            family, module=module, params=params, param_visibilities=\n            param_visibilities)\n    else:\n        _default_task = None\n    task = self._state.get_task(task_id, setdefault=_default_task)\n    if task is None or task.status != RUNNING and not worker.enabled:\n        return\n    if status == PENDING and task.status == DONE and time.time(\n        ) - task.updated < self._config.stable_done_cooldown_secs:\n        return\n    if not task.family:\n        task.family = family\n    if not getattr(task, 'module', None):\n        task.module = module\n    if not getattr(task, 'param_visibilities', None):\n        task.param_visibilities = _get_default(param_visibilities, {})\n    if not task.params:\n        task.set_params(params)\n    if batch_id is not None:\n        task.batch_id = batch_id\n    if status == RUNNING and not task.worker_running:\n        task.worker_running = worker_id\n        if batch_id:\n            batch_tasks = self._state.get_batch_running_tasks(batch_id)\n            task.resources_running = batch_tasks[0].resources_running.copy()\n        task.time_running = time.time()\n    if accepts_messages is not None:\n        task.accepts_messages = accepts_messages\n    if tracking_url is not None or task.status != RUNNING:\n        task.tracking_url = tracking_url\n        if task.batch_id is not None:\n            for batch_task in self._state.get_batch_running_tasks(task.batch_id\n                ):\n                batch_task.tracking_url = tracking_url\n    if batchable is not None:\n        task.batchable = batchable\n    if task.remove is not None:\n        task.remove = None\n    if expl is not None:\n        task.expl = expl\n        if task.batch_id is not None:\n            for batch_task in self._state.get_batch_running_tasks(task.batch_id\n                ):\n                batch_task.expl = expl\n    task_is_not_running = task.status not in (RUNNING, BATCH_RUNNING)\n    task_started_a_run = status in (DONE, FAILED, RUNNING)\n    running_on_this_worker = task.worker_running == worker_id\n    if (task_is_not_running or task_started_a_run and\n        running_on_this_worker or new_deps):\n        if status != task.status or status == PENDING:\n            self._update_task_history(task, status)\n        self._state.set_status(task, PENDING if status == SUSPENDED else\n            status, self._config)\n    if status == FAILED and self._config.batch_emails:\n        batched_params, _ = self._state.get_batcher(worker_id, family)\n        if batched_params:\n            unbatched_params = {param: value for param, value in task.\n                params.items() if param not in batched_params}\n        else:\n            unbatched_params = task.params\n        try:\n            expl_raw = json.loads(expl)\n        except ValueError:\n            expl_raw = expl\n        self._email_batcher.add_failure(task.pretty_id, task.family,\n            unbatched_params, expl_raw, owners)\n        if task.status == DISABLED:\n            self._email_batcher.add_disable(task.pretty_id, task.family,\n                unbatched_params, owners)\n    if deps is not None:\n        task.deps = set(deps)\n    if new_deps is not None:\n        task.deps.update(new_deps)\n    if resources is not None:\n        task.resources = resources\n    if worker.enabled and not assistant:\n        task.stakeholders.add(worker_id)\n        for dep in (task.deps or []):\n            t = self._state.get_task(dep, setdefault=self._make_task(\n                task_id=dep, status=UNKNOWN, deps=None, priority=priority))\n            t.stakeholders.add(worker_id)\n    self._update_priority(task, priority, worker_id)\n    task.retry_policy = retry_policy\n    if runnable and status != FAILED and worker.enabled:\n        task.workers.add(worker_id)\n        self._state.get_worker(worker_id).tasks.add(task)\n        task.runnable = runnable\n", "function_parameter": "(self, task_id=None, status=PENDING, runnable=True, deps=None,\n    new_deps=None, expl=None, resources=None, priority=0, family='', module\n    =None, params=None, param_visibilities=None, accepts_messages=False,\n    assistant=False, tracking_url=None, worker=None, batchable=None,\n    batch_id=None, retry_policy_dict=None, owners=None, **kwargs)", "called_function_name": "set_status", "called_function_parameter": "(self, task, new_status, config=None)", "called_arguments": "(task, PENDING if status == SUSPENDED else\n            status, self._config)", "user_prompt": "The function `add_task` needs to be analyzed is as below:\n```python\n@rpc_method()\ndef add_task(self, task_id=None, status=PENDING, runnable=True, deps=None,\n    new_deps=None, expl=None, resources=None, priority=0, family='', module\n    =None, params=None, param_visibilities=None, accepts_messages=False,\n    assistant=False, tracking_url=None, worker=None, batchable=None,\n    batch_id=None, retry_policy_dict=None, owners=None, **kwargs):\n    \"\"\"\n        * add task identified by task_id if it doesn't exist\n        * if deps is not None, update dependency list\n        * update status of task\n        * add additional workers/stakeholders\n        * update priority when needed\n        \"\"\"\n    assert worker is not None\n    worker_id = worker\n    worker = self._update_worker(worker_id)\n    resources = {} if resources is None else resources.copy()\n    if retry_policy_dict is None:\n        retry_policy_dict = {}\n    retry_policy = self._generate_retry_policy(retry_policy_dict)\n    if worker.enabled:\n        _default_task = self._make_task(task_id=task_id, status=PENDING,\n            deps=deps, resources=resources, priority=priority, family=\n            family, module=module, params=params, param_visibilities=\n            param_visibilities)\n    else:\n        _default_task = None\n    task = self._state.get_task(task_id, setdefault=_default_task)\n    if task is None or task.status != RUNNING and not worker.enabled:\n        return\n    if status == PENDING and task.status == DONE and time.time(\n        ) - task.updated < self._config.stable_done_cooldown_secs:\n        return\n    if not task.family:\n        task.family = family\n    if not getattr(task, 'module', None):\n        task.module = module\n    if not getattr(task, 'param_visibilities', None):\n        task.param_visibilities = _get_default(param_visibilities, {})\n    if not task.params:\n        task.set_params(params)\n    if batch_id is not None:\n        task.batch_id = batch_id\n    if status == RUNNING and not task.worker_running:\n        task.worker_running = worker_id\n        if batch_id:\n            batch_tasks = self._state.get_batch_running_tasks(batch_id)\n            task.resources_running = batch_tasks[0].resources_running.copy()\n        task.time_running = time.time()\n    if accepts_messages is not None:\n        task.accepts_messages = accepts_messages\n    if tracking_url is not None or task.status != RUNNING:\n        task.tracking_url = tracking_url\n        if task.batch_id is not None:\n            for batch_task in self._state.get_batch_running_tasks(task.batch_id\n                ):\n                batch_task.tracking_url = tracking_url\n    if batchable is not None:\n        task.batchable = batchable\n    if task.remove is not None:\n        task.remove = None\n    if expl is not None:\n        task.expl = expl\n        if task.batch_id is not None:\n            for batch_task in self._state.get_batch_running_tasks(task.batch_id\n                ):\n                batch_task.expl = expl\n    task_is_not_running = task.status not in (RUNNING, BATCH_RUNNING)\n    task_started_a_run = status in (DONE, FAILED, RUNNING)\n    running_on_this_worker = task.worker_running == worker_id\n    if (task_is_not_running or task_started_a_run and\n        running_on_this_worker or new_deps):\n        if status != task.status or status == PENDING:\n            self._update_task_history(task, status)\n        self._state.set_status(task, PENDING if status == SUSPENDED else\n            status, self._config)\n    if status == FAILED and self._config.batch_emails:\n        batched_params, _ = self._state.get_batcher(worker_id, family)\n        if batched_params:\n            unbatched_params = {param: value for param, value in task.\n                params.items() if param not in batched_params}\n        else:\n            unbatched_params = task.params\n        try:\n            expl_raw = json.loads(expl)\n        except ValueError:\n            expl_raw = expl\n        self._email_batcher.add_failure(task.pretty_id, task.family,\n            unbatched_params, expl_raw, owners)\n        if task.status == DISABLED:\n            self._email_batcher.add_disable(task.pretty_id, task.family,\n                unbatched_params, owners)\n    if deps is not None:\n        task.deps = set(deps)\n    if new_deps is not None:\n        task.deps.update(new_deps)\n    if resources is not None:\n        task.resources = resources\n    if worker.enabled and not assistant:\n        task.stakeholders.add(worker_id)\n        for dep in (task.deps or []):\n            t = self._state.get_task(dep, setdefault=self._make_task(\n                task_id=dep, status=UNKNOWN, deps=None, priority=priority))\n            t.stakeholders.add(worker_id)\n    self._update_priority(task, priority, worker_id)\n    task.retry_policy = retry_policy\n    if runnable and status != FAILED and worker.enabled:\n        task.workers.add(worker_id)\n        self._state.get_worker(worker_id).tasks.add(task)\n        task.runnable = runnable\n\n```\nYou are provided with type information for the arguments of the called function. Use this as backward-flow type information to guide your inference in the caller.\nFunction being called: `set_status`.\n\nArguments defined in this called function: `(self, task, new_status, config=None)`.\nArguments passed to this called function: `(task, PENDING if status == SUSPENDED else\n            status, self._config)`.\nThe function belongs to class `Scheduler`.\nThe constructor of the class is:\n```python\ndef __init__(self, config=None, resources=None, task_history_impl=None, **\n    kwargs):\n    \"\"\"\n        Keyword Arguments:\n        :param config: an object of class \"scheduler\" or None (in which the global instance will be used)\n        :param resources: a dict of str->int constraints\n        :param task_history_impl: ignore config and use this object as the task history\n        \"\"\"\n    self._config = config or scheduler(**kwargs)\n    self._state = SimpleTaskState(self._config.state_path)\n    if task_history_impl:\n        self._task_history = task_history_impl\n    elif self._config.record_task_history:\n        from luigi import db_task_history\n        self._task_history = db_task_history.DbTaskHistory()\n    else:\n        self._task_history = history.NopHistory()\n    self._resources = resources or configuration.get_config().getintdict(\n        'resources')\n    self._make_task = functools.partial(Task, retry_policy=self._config.\n        _get_retry_policy())\n    self._worker_requests = {}\n    self._paused = False\n    if self._config.batch_emails:\n        self._email_batcher = BatchNotifier()\n    self._state._metrics_collector = MetricsCollectors.get(self._config.\n        metrics_collector, self._config.metrics_custom_import)\n\n```\n\n\nKnown type information for this called function's parameters:\n```json\n{\n  \"self\": {\n    \"type\": \"class\",\n    \"fields\": {\n      \"_state_path\": {\n        \"type\": \"str\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"_tasks\": {\n        \"type\": \"dict\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": [\"__getitem__\", \"__setitem__\"]\n      },\n      \"_status_tasks\": {\n        \"type\": \"collections.defaultdict\",\n        \"fields\": {},\n        \"methods\": [\"pop\"],\n        \"built-in\": [\"__getitem__\", \"__setitem__\"]\n      },\n      \"_active_workers\": {\n        \"type\": \"dict\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": [\"__getitem__\", \"__setitem__\"]\n      },\n      \"_task_batchers\": {\n        \"type\": \"dict\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": [\"__getitem__\", \"__setitem__\"]\n      },\n      \"_metrics_collector\": {\n        \"type\": \"NoneType\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      }\n    },\n    \"methods\": [\"get_batch_running_tasks\", \"re_enable\", \"update_metrics\"],\n    \"built-in\": []\n  },\n  \"task\": {\n    \"type\": \"class\",\n    \"fields\": {\n      \"status\": {\n        \"type\": \"str\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"batch_id\": {\n        \"type\": \"NoneType\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"batchable\": {\n        \"type\": \"bool\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"scheduler_disable_time\": {\n        \"type\": \"float\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"id\": {\n        \"type\": \"str\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"retry_policy\": {\n        \"type\": \"class\",\n        \"fields\": {\n          \"retry_count\": {\n            \"type\": \"int\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          },\n          \"disable_window\": {\n            \"type\": \"int\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          }\n        },\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"updated\": {\n        \"type\": \"float\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"retry\": {\n        \"type\": \"float\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"remove\": {\n        \"type\": \"float\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      }\n    },\n    \"methods\": [\"add_failure\", \"has_excessive_failures\"],\n    \"built-in\": []\n  },\n  \"new_status\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"config\": {\n    \"type\": \"class\",\n    \"fields\": {\n      \"batch_emails\": {\n        \"type\": \"bool\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"disable_persist\": {\n        \"type\": \"int\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"retry_delay\": {\n        \"type\": \"int\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      }\n    },\n    \"methods\": [],\n    \"built-in\": []\n  }\n}\n```\nPlease infer the type, fields, methods, and built-in characteristics of each parameter based on its usage within the function `add_task`, and using any constraints from the callee if available. Provide the result in JSON format. Please only output the JSON result without any additional explanations or comments.", "llm_output": "```json\n{\n  \"self\": {\n    \"type\": \"class\",\n    \"fields\": {\n      \"_config\": {\n        \"type\": \"class\",\n        \"fields\": {\n          \"stable_done_cooldown_secs\": {\n            \"type\": \"float\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          },\n          \"batch_emails\": {\n            \"type\": \"bool\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          },\n          \"record_task_history\": {\n            \"type\": \"bool\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          },\n          \"metrics_collector\": {\n            \"type\": \"str\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          },\n          \"metrics_custom_import\": {\n            \"type\": \"str\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          },\n          \"state_path\": {\n            \"type\": \"str\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          }\n        },\n        \"methods\": [\"_get_retry_policy\"],\n        \"built-in\": []\n      },\n      \"_state\": {\n        \"type\": \"class\",\n        \"fields\": {},\n        \"methods\": [\"get_task\", \"get_batch_running_tasks\", \"get_batcher\", \"get_worker\", \"set_status\"],\n        \"built-in\": []\n      },\n      \"_task_history\": {\n        \"type\": \"class\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"_resources\": {\n        \"type\": \"dict\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": [\"__getitem__\", \"__setitem__\"]\n      },\n      \"_make_task\": {\n        \"type\": \"functools.partial\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"_worker_requests\": {\n        \"type\": \"dict\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": [\"__getitem__\", \"__setitem__\"]\n      },\n      \"_paused\": {\n        \"type\": \"bool\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"_email_batcher\": {\n        \"type\": \"class\",\n        \"fields\": {},\n        \"methods\": [\"add_failure\", \"add_disable\"],\n        \"built-in\": []\n      }\n    },\n    \"methods\": [\"_update_worker\", \"_generate_retry_policy\", \"_update_task_history\", \"_update_priority\"],\n    \"built-in\": []\n  },\n  \"task_id\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"status\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"runnable\": {\n    \"type\": \"bool\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"deps\": {\n    \"type\": \"list\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": [\"__iter__\"]\n  },\n  \"new_deps\": {\n    \"type\": \"list\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": [\"__iter__\"]\n  },\n  \"expl\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"resources\": {\n    \"type\": \"dict\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": [\"__getitem__\", \"__setitem__\", \"copy\"]\n  },\n  \"priority\": {\n    \"type\": \"int\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"family\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"module\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"params\": {\n    \"type\": \"dict\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": [\"__getitem__\", \"__setitem__\"]\n  },\n  \"param_visibilities\": {\n    \"type\": \"dict\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": [\"__getitem__\", \"__setitem__\"]\n  },\n  \"accepts_messages\": {\n    \"type\": \"bool\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"assistant\": {\n    \"type\": \"bool\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"tracking_url\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"worker\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"batchable\": {\n    \"type\": \"bool\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"batch_id\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"retry_policy_dict\": {\n    \"type\": \"dict\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": [\"__getitem__\", \"__setitem__\"]\n  },\n  \"owners\": {\n    \"type\": \"list\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": [\"__iter__\"]\n  },\n  \"kwargs\": {\n    \"type\": \"dict\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": [\"__getitem__\", \"__setitem__\"]\n  }\n}\n```"}
