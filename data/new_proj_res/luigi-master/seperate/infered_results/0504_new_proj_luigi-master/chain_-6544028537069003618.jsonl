{"function_name": "_prefix", "function_content": "def _prefix(subject):\n    \"\"\"\n    If the config has a special prefix for emails then this function adds\n    this prefix.\n    \"\"\"\n    if email().prefix:\n        return '{} {}'.format(email().prefix, subject)\n    else:\n        return subject\n", "function_parameter": "(subject)", "called_function_name": "", "called_function_parameter": "", "called_arguments": "", "user_prompt": "The function `_prefix` needs to be analyzed is as below:\n```python\ndef _prefix(subject):\n    \"\"\"\n    If the config has a special prefix for emails then this function adds\n    this prefix.\n    \"\"\"\n    if email().prefix:\n        return '{} {}'.format(email().prefix, subject)\n    else:\n        return subject\n\n```\n\nPlease infer the type, fields, methods, and built-in characteristics of each parameter based on its usage within the function `_prefix`, and using any constraints from the callee if available. Provide the result in JSON format. Please only output the JSON result without any additional explanations or comments.", "llm_output": "```json\n{\n  \"subject\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  }\n}\n```"}
{"function_name": "send_email", "function_content": "def send_email(subject, message, sender, recipients, image_png=None):\n    \"\"\"\n    Decides whether to send notification. Notification is cancelled if there are\n    no recipients or if stdout is onto tty or if in debug mode.\n\n    Dispatches on config value email.method.  Default is 'smtp'.\n    \"\"\"\n    notifiers = {'ses': send_email_ses, 'sendgrid': send_email_sendgrid,\n        'smtp': send_email_smtp, 'sns': send_email_sns}\n    subject = _prefix(subject)\n    if not recipients or recipients == (None,):\n        return\n    if _email_disabled_reason():\n        logger.info('Not sending email to %r because %s', recipients,\n            _email_disabled_reason())\n        return\n    recipients_tmp = []\n    for r in recipients:\n        recipients_tmp.extend([a.strip() for a in r.split(',') if a.strip()])\n    recipients = recipients_tmp\n    logger.info('Sending email to %r', recipients)\n    email_sender = notifiers[email().method]\n    email_sender(sender, subject, message, recipients, image_png)\n", "function_parameter": "(subject, message, sender, recipients, image_png=None)", "called_function_name": "_prefix", "called_function_parameter": "(subject)", "called_arguments": "(subject)", "user_prompt": "The function `send_email` needs to be analyzed is as below:\n```python\ndef send_email(subject, message, sender, recipients, image_png=None):\n    \"\"\"\n    Decides whether to send notification. Notification is cancelled if there are\n    no recipients or if stdout is onto tty or if in debug mode.\n\n    Dispatches on config value email.method.  Default is 'smtp'.\n    \"\"\"\n    notifiers = {'ses': send_email_ses, 'sendgrid': send_email_sendgrid,\n        'smtp': send_email_smtp, 'sns': send_email_sns}\n    subject = _prefix(subject)\n    if not recipients or recipients == (None,):\n        return\n    if _email_disabled_reason():\n        logger.info('Not sending email to %r because %s', recipients,\n            _email_disabled_reason())\n        return\n    recipients_tmp = []\n    for r in recipients:\n        recipients_tmp.extend([a.strip() for a in r.split(',') if a.strip()])\n    recipients = recipients_tmp\n    logger.info('Sending email to %r', recipients)\n    email_sender = notifiers[email().method]\n    email_sender(sender, subject, message, recipients, image_png)\n\n```\nYou are provided with type information for the arguments of the called function. Use this as backward-flow type information to guide your inference in the caller.\nFunction being called: `_prefix`.\n\nArguments defined in this called function: `(subject)`.\nArguments passed to this called function: `(subject)`.\n\n\nKnown type information for this called function's parameters:\n```json\n{\n  \"subject\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  }\n}\n```\nPlease infer the type, fields, methods, and built-in characteristics of each parameter based on its usage within the function `send_email`, and using any constraints from the callee if available. Provide the result in JSON format. Please only output the JSON result without any additional explanations or comments.", "llm_output": "```json\n{\n  \"subject\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"message\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"sender\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"recipients\": {\n    \"type\": \"tuple\",\n    \"fields\": {},\n    \"methods\": [\"split\"],\n    \"built-in\": [\"__iter__\"]\n  },\n  \"image_png\": {\n    \"type\": \"bytes\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  }\n}\n```"}
{"function_name": "send_error_email", "function_content": "def send_error_email(subject, message, additional_recipients=None):\n    \"\"\"\n    Sends an email to the configured error email, if it's configured.\n    \"\"\"\n    recipients = _email_recipients(additional_recipients)\n    sender = email().sender\n    send_email(subject=subject, message=message, sender=sender, recipients=\n        recipients)\n", "function_parameter": "(subject, message, additional_recipients=None)", "called_function_name": "send_email", "called_function_parameter": "(subject, message, sender, recipients, image_png=None)", "called_arguments": "(subject=subject, message=message, sender=sender, recipients=\n        recipients)", "user_prompt": "The function `send_error_email` needs to be analyzed is as below:\n```python\ndef send_error_email(subject, message, additional_recipients=None):\n    \"\"\"\n    Sends an email to the configured error email, if it's configured.\n    \"\"\"\n    recipients = _email_recipients(additional_recipients)\n    sender = email().sender\n    send_email(subject=subject, message=message, sender=sender, recipients=\n        recipients)\n\n```\nYou are provided with type information for the arguments of the called function. Use this as backward-flow type information to guide your inference in the caller.\nFunction being called: `send_email`.\n\nArguments defined in this called function: `(subject, message, sender, recipients, image_png=None)`.\nArguments passed to this called function: `(subject=subject, message=message, sender=sender, recipients=\n        recipients)`.\n\n\nKnown type information for this called function's parameters:\n```json\n{\n  \"subject\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"message\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"sender\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"recipients\": {\n    \"type\": \"tuple\",\n    \"fields\": {},\n    \"methods\": [\"split\"],\n    \"built-in\": [\"__iter__\"]\n  },\n  \"image_png\": {\n    \"type\": \"bytes\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  }\n}\n```\nPlease infer the type, fields, methods, and built-in characteristics of each parameter based on its usage within the function `send_error_email`, and using any constraints from the callee if available. Provide the result in JSON format. Please only output the JSON result without any additional explanations or comments.", "llm_output": "```json\n{\n  \"subject\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"message\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"additional_recipients\": {\n    \"type\": \"tuple\",\n    \"fields\": {},\n    \"methods\": [\"split\"],\n    \"built-in\": [\"__iter__\"]\n  }\n}\n```"}
{"function_name": "set_status", "function_content": "def set_status(self, task, new_status, config=None):\n    if new_status == FAILED:\n        assert config is not None\n    if new_status == DISABLED and task.status in (RUNNING, BATCH_RUNNING):\n        return\n    remove_on_failure = task.batch_id is not None and not task.batchable\n    if task.status == DISABLED:\n        if new_status == DONE:\n            self.re_enable(task)\n        elif task.scheduler_disable_time is not None and new_status != DISABLED:\n            return\n    if (task.status == RUNNING and task.batch_id is not None and new_status !=\n        RUNNING):\n        for batch_task in self.get_batch_running_tasks(task.batch_id):\n            self.set_status(batch_task, new_status, config)\n            batch_task.batch_id = None\n        task.batch_id = None\n    if new_status == FAILED and task.status != DISABLED:\n        task.add_failure()\n        if task.has_excessive_failures():\n            task.scheduler_disable_time = time.time()\n            new_status = DISABLED\n            if not config.batch_emails:\n                notifications.send_error_email(\n                    'Luigi Scheduler: DISABLED {task} due to excessive failures'\n                    .format(task=task.id),\n                    '{task} failed {failures} times in the last {window} seconds, so it is being disabled for {persist} seconds'\n                    .format(failures=task.retry_policy.retry_count, task=\n                    task.id, window=task.retry_policy.disable_window,\n                    persist=config.disable_persist))\n    elif new_status == DISABLED:\n        task.scheduler_disable_time = None\n    if new_status != task.status:\n        self._status_tasks[task.status].pop(task.id)\n        self._status_tasks[new_status][task.id] = task\n        task.status = new_status\n        task.updated = time.time()\n        self.update_metrics(task, config)\n    if new_status == FAILED:\n        task.retry = time.time() + config.retry_delay\n        if remove_on_failure:\n            task.remove = time.time()\n", "function_parameter": "(self, task, new_status, config=None)", "called_function_name": "send_error_email", "called_function_parameter": "(subject, message, additional_recipients=None)", "called_arguments": "(\n                    'Luigi Scheduler: DISABLED {task} due to excessive failures'\n                    .format(task=task.id),\n                    '{task} failed {failures} times in the last {window} seconds, so it is being disabled for {persist} seconds'\n                    .format(failures=task.retry_policy.retry_count, task=\n                    task.id, window=task.retry_policy.disable_window,\n                    persist=config.disable_persist))", "user_prompt": "The function `set_status` needs to be analyzed is as below:\n```python\ndef set_status(self, task, new_status, config=None):\n    if new_status == FAILED:\n        assert config is not None\n    if new_status == DISABLED and task.status in (RUNNING, BATCH_RUNNING):\n        return\n    remove_on_failure = task.batch_id is not None and not task.batchable\n    if task.status == DISABLED:\n        if new_status == DONE:\n            self.re_enable(task)\n        elif task.scheduler_disable_time is not None and new_status != DISABLED:\n            return\n    if (task.status == RUNNING and task.batch_id is not None and new_status !=\n        RUNNING):\n        for batch_task in self.get_batch_running_tasks(task.batch_id):\n            self.set_status(batch_task, new_status, config)\n            batch_task.batch_id = None\n        task.batch_id = None\n    if new_status == FAILED and task.status != DISABLED:\n        task.add_failure()\n        if task.has_excessive_failures():\n            task.scheduler_disable_time = time.time()\n            new_status = DISABLED\n            if not config.batch_emails:\n                notifications.send_error_email(\n                    'Luigi Scheduler: DISABLED {task} due to excessive failures'\n                    .format(task=task.id),\n                    '{task} failed {failures} times in the last {window} seconds, so it is being disabled for {persist} seconds'\n                    .format(failures=task.retry_policy.retry_count, task=\n                    task.id, window=task.retry_policy.disable_window,\n                    persist=config.disable_persist))\n    elif new_status == DISABLED:\n        task.scheduler_disable_time = None\n    if new_status != task.status:\n        self._status_tasks[task.status].pop(task.id)\n        self._status_tasks[new_status][task.id] = task\n        task.status = new_status\n        task.updated = time.time()\n        self.update_metrics(task, config)\n    if new_status == FAILED:\n        task.retry = time.time() + config.retry_delay\n        if remove_on_failure:\n            task.remove = time.time()\n\n```\nYou are provided with type information for the arguments of the called function. Use this as backward-flow type information to guide your inference in the caller.\nFunction being called: `send_error_email`.\n\nArguments defined in this called function: `(subject, message, additional_recipients=None)`.\nArguments passed to this called function: `(\n                    'Luigi Scheduler: DISABLED {task} due to excessive failures'\n                    .format(task=task.id),\n                    '{task} failed {failures} times in the last {window} seconds, so it is being disabled for {persist} seconds'\n                    .format(failures=task.retry_policy.retry_count, task=\n                    task.id, window=task.retry_policy.disable_window,\n                    persist=config.disable_persist))`.\nThe function belongs to class `SimpleTaskState`.\nThe constructor of the class is:\n```python\ndef __init__(self, state_path):\n    self._state_path = state_path\n    self._tasks = {}\n    self._status_tasks = collections.defaultdict(dict)\n    self._active_workers = {}\n    self._task_batchers = {}\n    self._metrics_collector = None\n\n```\n\n\nKnown type information for this called function's parameters:\n```json\n{\n  \"subject\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"message\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"additional_recipients\": {\n    \"type\": \"tuple\",\n    \"fields\": {},\n    \"methods\": [\"split\"],\n    \"built-in\": [\"__iter__\"]\n  }\n}\n```\nPlease infer the type, fields, methods, and built-in characteristics of each parameter based on its usage within the function `set_status`, and using any constraints from the callee if available. Provide the result in JSON format. Please only output the JSON result without any additional explanations or comments.", "llm_output": "```json\n{\n  \"self\": {\n    \"type\": \"class\",\n    \"fields\": {\n      \"_state_path\": {\n        \"type\": \"str\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"_tasks\": {\n        \"type\": \"dict\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": [\"__getitem__\", \"__setitem__\"]\n      },\n      \"_status_tasks\": {\n        \"type\": \"collections.defaultdict\",\n        \"fields\": {},\n        \"methods\": [\"pop\"],\n        \"built-in\": [\"__getitem__\", \"__setitem__\"]\n      },\n      \"_active_workers\": {\n        \"type\": \"dict\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": [\"__getitem__\", \"__setitem__\"]\n      },\n      \"_task_batchers\": {\n        \"type\": \"dict\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": [\"__getitem__\", \"__setitem__\"]\n      },\n      \"_metrics_collector\": {\n        \"type\": \"NoneType\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      }\n    },\n    \"methods\": [\"get_batch_running_tasks\", \"re_enable\", \"update_metrics\"],\n    \"built-in\": []\n  },\n  \"task\": {\n    \"type\": \"class\",\n    \"fields\": {\n      \"status\": {\n        \"type\": \"str\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"batch_id\": {\n        \"type\": \"NoneType\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"batchable\": {\n        \"type\": \"bool\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"scheduler_disable_time\": {\n        \"type\": \"float\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"id\": {\n        \"type\": \"str\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"retry_policy\": {\n        \"type\": \"class\",\n        \"fields\": {\n          \"retry_count\": {\n            \"type\": \"int\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          },\n          \"disable_window\": {\n            \"type\": \"int\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          }\n        },\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"updated\": {\n        \"type\": \"float\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"retry\": {\n        \"type\": \"float\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"remove\": {\n        \"type\": \"float\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      }\n    },\n    \"methods\": [\"add_failure\", \"has_excessive_failures\"],\n    \"built-in\": []\n  },\n  \"new_status\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"config\": {\n    \"type\": \"class\",\n    \"fields\": {\n      \"batch_emails\": {\n        \"type\": \"bool\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"disable_persist\": {\n        \"type\": \"int\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"retry_delay\": {\n        \"type\": \"int\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      }\n    },\n    \"methods\": [],\n    \"built-in\": []\n  }\n}\n```"}
{"function_name": "get_work", "function_content": "@rpc_method(allow_null=False)\ndef get_work(self, host=None, assistant=False, current_tasks=None, worker=\n    None, **kwargs):\n    if self._config.prune_on_get_work:\n        self.prune()\n    assert worker is not None\n    worker_id = worker\n    worker = self._update_worker(worker_id, worker_reference={'host': host},\n        get_work=True)\n    if not worker.enabled:\n        reply = {'n_pending_tasks': 0, 'running_tasks': [], 'task_id': None,\n            'n_unique_pending': 0, 'worker_state': worker.state}\n        return reply\n    if assistant:\n        self.add_worker(worker_id, [('assistant', assistant)])\n    batched_params, unbatched_params, batched_tasks, max_batch_size = (None,\n        None, [], 1)\n    best_task = None\n    if current_tasks is not None:\n        ct_set = set(current_tasks)\n        for task in sorted(self._state.get_active_tasks_by_status(RUNNING),\n            key=self._rank):\n            if task.worker_running == worker_id and task.id not in ct_set:\n                best_task = task\n    if current_tasks is not None:\n        self._reset_orphaned_batch_running_tasks(worker_id)\n    greedy_resources = collections.defaultdict(int)\n    worker = self._state.get_worker(worker_id)\n    if self._paused:\n        relevant_tasks = []\n    elif worker.is_trivial_worker(self._state):\n        relevant_tasks = worker.get_tasks(self._state, PENDING, RUNNING)\n        used_resources = collections.defaultdict(int)\n        greedy_workers = dict()\n    else:\n        relevant_tasks = self._state.get_active_tasks_by_status(PENDING,\n            RUNNING)\n        used_resources = self._used_resources()\n        activity_limit = time.time() - self._config.worker_disconnect_delay\n        active_workers = self._state.get_active_workers(last_get_work_gt=\n            activity_limit)\n        greedy_workers = dict((worker.id, worker.info.get('workers', 1)) for\n            worker in active_workers)\n    tasks = list(relevant_tasks)\n    tasks.sort(key=self._rank, reverse=True)\n    for task in tasks:\n        if (best_task and batched_params and task.family == best_task.\n            family and len(batched_tasks) < max_batch_size and task.\n            is_batchable() and all(task.params.get(name) == value for name,\n            value in unbatched_params.items()) and task.resources ==\n            best_task.resources and self._schedulable(task)):\n            for name, params in batched_params.items():\n                params.append(task.params.get(name))\n            batched_tasks.append(task)\n        if best_task:\n            continue\n        if task.status == RUNNING and task.worker_running in greedy_workers:\n            greedy_workers[task.worker_running] -= 1\n            for resource, amount in (getattr(task, 'resources_running',\n                task.resources) or {}).items():\n                greedy_resources[resource] += amount\n        if self._schedulable(task) and self._has_resources(task.resources,\n            greedy_resources):\n            in_workers = (assistant and task.runnable or worker_id in task.\n                workers)\n            if in_workers and self._has_resources(task.resources,\n                used_resources):\n                best_task = task\n                batch_param_names, max_batch_size = self._state.get_batcher(\n                    worker_id, task.family)\n                if batch_param_names and task.is_batchable():\n                    try:\n                        batched_params = {name: [task.params[name]] for\n                            name in batch_param_names}\n                        unbatched_params = {name: value for name, value in\n                            task.params.items() if name not in batched_params}\n                        batched_tasks.append(task)\n                    except KeyError:\n                        batched_params, unbatched_params = None, None\n            else:\n                workers = itertools.chain(task.workers, [worker_id]\n                    ) if assistant else task.workers\n                for task_worker in workers:\n                    if greedy_workers.get(task_worker, 0) > 0:\n                        greedy_workers[task_worker] -= 1\n                        for resource, amount in (task.resources or {}).items():\n                            greedy_resources[resource] += amount\n                        break\n    reply = self.count_pending(worker_id)\n    if len(batched_tasks) > 1:\n        batch_string = '|'.join(task.id for task in batched_tasks)\n        batch_id = hashlib.new('md5', batch_string.encode('utf-8'),\n            usedforsecurity=False).hexdigest()\n        for task in batched_tasks:\n            self._state.set_batch_running(task, batch_id, worker_id)\n        combined_params = best_task.params.copy()\n        combined_params.update(batched_params)\n        reply['task_id'] = None\n        reply['task_family'] = best_task.family\n        reply['task_module'] = getattr(best_task, 'module', None)\n        reply['task_params'] = combined_params\n        reply['batch_id'] = batch_id\n        reply['batch_task_ids'] = [task.id for task in batched_tasks]\n    elif best_task:\n        self.update_metrics_task_started(best_task)\n        self._state.set_status(best_task, RUNNING, self._config)\n        best_task.worker_running = worker_id\n        best_task.resources_running = best_task.resources.copy()\n        best_task.time_running = time.time()\n        self._update_task_history(best_task, RUNNING, host=host)\n        reply['task_id'] = best_task.id\n        reply['task_family'] = best_task.family\n        reply['task_module'] = getattr(best_task, 'module', None)\n        reply['task_params'] = best_task.params\n    else:\n        reply['task_id'] = None\n    return reply\n", "function_parameter": "(self, host=None, assistant=False, current_tasks=None, worker=\n    None, **kwargs)", "called_function_name": "set_status", "called_function_parameter": "(self, task, new_status, config=None)", "called_arguments": "(best_task, RUNNING, self._config)", "user_prompt": "The function `get_work` needs to be analyzed is as below:\n```python\n@rpc_method(allow_null=False)\ndef get_work(self, host=None, assistant=False, current_tasks=None, worker=\n    None, **kwargs):\n    if self._config.prune_on_get_work:\n        self.prune()\n    assert worker is not None\n    worker_id = worker\n    worker = self._update_worker(worker_id, worker_reference={'host': host},\n        get_work=True)\n    if not worker.enabled:\n        reply = {'n_pending_tasks': 0, 'running_tasks': [], 'task_id': None,\n            'n_unique_pending': 0, 'worker_state': worker.state}\n        return reply\n    if assistant:\n        self.add_worker(worker_id, [('assistant', assistant)])\n    batched_params, unbatched_params, batched_tasks, max_batch_size = (None,\n        None, [], 1)\n    best_task = None\n    if current_tasks is not None:\n        ct_set = set(current_tasks)\n        for task in sorted(self._state.get_active_tasks_by_status(RUNNING),\n            key=self._rank):\n            if task.worker_running == worker_id and task.id not in ct_set:\n                best_task = task\n    if current_tasks is not None:\n        self._reset_orphaned_batch_running_tasks(worker_id)\n    greedy_resources = collections.defaultdict(int)\n    worker = self._state.get_worker(worker_id)\n    if self._paused:\n        relevant_tasks = []\n    elif worker.is_trivial_worker(self._state):\n        relevant_tasks = worker.get_tasks(self._state, PENDING, RUNNING)\n        used_resources = collections.defaultdict(int)\n        greedy_workers = dict()\n    else:\n        relevant_tasks = self._state.get_active_tasks_by_status(PENDING,\n            RUNNING)\n        used_resources = self._used_resources()\n        activity_limit = time.time() - self._config.worker_disconnect_delay\n        active_workers = self._state.get_active_workers(last_get_work_gt=\n            activity_limit)\n        greedy_workers = dict((worker.id, worker.info.get('workers', 1)) for\n            worker in active_workers)\n    tasks = list(relevant_tasks)\n    tasks.sort(key=self._rank, reverse=True)\n    for task in tasks:\n        if (best_task and batched_params and task.family == best_task.\n            family and len(batched_tasks) < max_batch_size and task.\n            is_batchable() and all(task.params.get(name) == value for name,\n            value in unbatched_params.items()) and task.resources ==\n            best_task.resources and self._schedulable(task)):\n            for name, params in batched_params.items():\n                params.append(task.params.get(name))\n            batched_tasks.append(task)\n        if best_task:\n            continue\n        if task.status == RUNNING and task.worker_running in greedy_workers:\n            greedy_workers[task.worker_running] -= 1\n            for resource, amount in (getattr(task, 'resources_running',\n                task.resources) or {}).items():\n                greedy_resources[resource] += amount\n        if self._schedulable(task) and self._has_resources(task.resources,\n            greedy_resources):\n            in_workers = (assistant and task.runnable or worker_id in task.\n                workers)\n            if in_workers and self._has_resources(task.resources,\n                used_resources):\n                best_task = task\n                batch_param_names, max_batch_size = self._state.get_batcher(\n                    worker_id, task.family)\n                if batch_param_names and task.is_batchable():\n                    try:\n                        batched_params = {name: [task.params[name]] for\n                            name in batch_param_names}\n                        unbatched_params = {name: value for name, value in\n                            task.params.items() if name not in batched_params}\n                        batched_tasks.append(task)\n                    except KeyError:\n                        batched_params, unbatched_params = None, None\n            else:\n                workers = itertools.chain(task.workers, [worker_id]\n                    ) if assistant else task.workers\n                for task_worker in workers:\n                    if greedy_workers.get(task_worker, 0) > 0:\n                        greedy_workers[task_worker] -= 1\n                        for resource, amount in (task.resources or {}).items():\n                            greedy_resources[resource] += amount\n                        break\n    reply = self.count_pending(worker_id)\n    if len(batched_tasks) > 1:\n        batch_string = '|'.join(task.id for task in batched_tasks)\n        batch_id = hashlib.new('md5', batch_string.encode('utf-8'),\n            usedforsecurity=False).hexdigest()\n        for task in batched_tasks:\n            self._state.set_batch_running(task, batch_id, worker_id)\n        combined_params = best_task.params.copy()\n        combined_params.update(batched_params)\n        reply['task_id'] = None\n        reply['task_family'] = best_task.family\n        reply['task_module'] = getattr(best_task, 'module', None)\n        reply['task_params'] = combined_params\n        reply['batch_id'] = batch_id\n        reply['batch_task_ids'] = [task.id for task in batched_tasks]\n    elif best_task:\n        self.update_metrics_task_started(best_task)\n        self._state.set_status(best_task, RUNNING, self._config)\n        best_task.worker_running = worker_id\n        best_task.resources_running = best_task.resources.copy()\n        best_task.time_running = time.time()\n        self._update_task_history(best_task, RUNNING, host=host)\n        reply['task_id'] = best_task.id\n        reply['task_family'] = best_task.family\n        reply['task_module'] = getattr(best_task, 'module', None)\n        reply['task_params'] = best_task.params\n    else:\n        reply['task_id'] = None\n    return reply\n\n```\nYou are provided with type information for the arguments of the called function. Use this as backward-flow type information to guide your inference in the caller.\nFunction being called: `set_status`.\n\nArguments defined in this called function: `(self, task, new_status, config=None)`.\nArguments passed to this called function: `(best_task, RUNNING, self._config)`.\nThe function belongs to class `Scheduler`.\nThe constructor of the class is:\n```python\ndef __init__(self, config=None, resources=None, task_history_impl=None, **\n    kwargs):\n    \"\"\"\n        Keyword Arguments:\n        :param config: an object of class \"scheduler\" or None (in which the global instance will be used)\n        :param resources: a dict of str->int constraints\n        :param task_history_impl: ignore config and use this object as the task history\n        \"\"\"\n    self._config = config or scheduler(**kwargs)\n    self._state = SimpleTaskState(self._config.state_path)\n    if task_history_impl:\n        self._task_history = task_history_impl\n    elif self._config.record_task_history:\n        from luigi import db_task_history\n        self._task_history = db_task_history.DbTaskHistory()\n    else:\n        self._task_history = history.NopHistory()\n    self._resources = resources or configuration.get_config().getintdict(\n        'resources')\n    self._make_task = functools.partial(Task, retry_policy=self._config.\n        _get_retry_policy())\n    self._worker_requests = {}\n    self._paused = False\n    if self._config.batch_emails:\n        self._email_batcher = BatchNotifier()\n    self._state._metrics_collector = MetricsCollectors.get(self._config.\n        metrics_collector, self._config.metrics_custom_import)\n\n```\n\n\nKnown type information for this called function's parameters:\n```json\n{\n  \"self\": {\n    \"type\": \"class\",\n    \"fields\": {\n      \"_state_path\": {\n        \"type\": \"str\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"_tasks\": {\n        \"type\": \"dict\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": [\"__getitem__\", \"__setitem__\"]\n      },\n      \"_status_tasks\": {\n        \"type\": \"collections.defaultdict\",\n        \"fields\": {},\n        \"methods\": [\"pop\"],\n        \"built-in\": [\"__getitem__\", \"__setitem__\"]\n      },\n      \"_active_workers\": {\n        \"type\": \"dict\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": [\"__getitem__\", \"__setitem__\"]\n      },\n      \"_task_batchers\": {\n        \"type\": \"dict\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": [\"__getitem__\", \"__setitem__\"]\n      },\n      \"_metrics_collector\": {\n        \"type\": \"NoneType\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      }\n    },\n    \"methods\": [\"get_batch_running_tasks\", \"re_enable\", \"update_metrics\"],\n    \"built-in\": []\n  },\n  \"task\": {\n    \"type\": \"class\",\n    \"fields\": {\n      \"status\": {\n        \"type\": \"str\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"batch_id\": {\n        \"type\": \"NoneType\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"batchable\": {\n        \"type\": \"bool\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"scheduler_disable_time\": {\n        \"type\": \"float\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"id\": {\n        \"type\": \"str\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"retry_policy\": {\n        \"type\": \"class\",\n        \"fields\": {\n          \"retry_count\": {\n            \"type\": \"int\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          },\n          \"disable_window\": {\n            \"type\": \"int\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          }\n        },\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"updated\": {\n        \"type\": \"float\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"retry\": {\n        \"type\": \"float\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"remove\": {\n        \"type\": \"float\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      }\n    },\n    \"methods\": [\"add_failure\", \"has_excessive_failures\"],\n    \"built-in\": []\n  },\n  \"new_status\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"config\": {\n    \"type\": \"class\",\n    \"fields\": {\n      \"batch_emails\": {\n        \"type\": \"bool\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"disable_persist\": {\n        \"type\": \"int\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"retry_delay\": {\n        \"type\": \"int\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      }\n    },\n    \"methods\": [],\n    \"built-in\": []\n  }\n}\n```\nPlease infer the type, fields, methods, and built-in characteristics of each parameter based on its usage within the function `get_work`, and using any constraints from the callee if available. Provide the result in JSON format. Please only output the JSON result without any additional explanations or comments.", "llm_output": "```json\n{\n  \"self\": {\n    \"type\": \"class\",\n    \"fields\": {\n      \"_config\": {\n        \"type\": \"class\",\n        \"fields\": {\n          \"prune_on_get_work\": {\n            \"type\": \"bool\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          },\n          \"worker_disconnect_delay\": {\n            \"type\": \"float\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          },\n          \"state_path\": {\n            \"type\": \"str\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          },\n          \"record_task_history\": {\n            \"type\": \"bool\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          },\n          \"batch_emails\": {\n            \"type\": \"bool\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          },\n          \"metrics_collector\": {\n            \"type\": \"str\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          },\n          \"metrics_custom_import\": {\n            \"type\": \"str\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          }\n        },\n        \"methods\": [\"_get_retry_policy\"],\n        \"built-in\": []\n      },\n      \"_state\": {\n        \"type\": \"class\",\n        \"fields\": {\n          \"_metrics_collector\": {\n            \"type\": \"NoneType\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          }\n        },\n        \"methods\": [\n          \"get_active_tasks_by_status\",\n          \"get_worker\",\n          \"get_active_workers\",\n          \"set_batch_running\",\n          \"set_status\",\n          \"get_batcher\"\n        ],\n        \"built-in\": []\n      },\n      \"_paused\": {\n        \"type\": \"bool\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"_resources\": {\n        \"type\": \"dict\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": [\"__getitem__\", \"__setitem__\"]\n      },\n      \"_worker_requests\": {\n        \"type\": \"dict\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": [\"__getitem__\", \"__setitem__\"]\n      },\n      \"_email_batcher\": {\n        \"type\": \"class\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"_make_task\": {\n        \"type\": \"functools.partial\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"_task_history\": {\n        \"type\": \"class\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      }\n    },\n    \"methods\": [\n      \"prune\",\n      \"_update_worker\",\n      \"add_worker\",\n      \"_reset_orphaned_batch_running_tasks\",\n      \"_used_resources\",\n      \"_rank\",\n      \"_schedulable\",\n      \"_has_resources\",\n      \"count_pending\",\n      \"update_metrics_task_started\",\n      \"_update_task_history\"\n    ],\n    \"built-in\": []\n  },\n  \"host\": {\n    \"type\": \"str\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"assistant\": {\n    \"type\": \"bool\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": []\n  },\n  \"current_tasks\": {\n    \"type\": \"list\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": [\"__iter__\"]\n  },\n  \"worker\": {\n    \"type\": \"class\",\n    \"fields\": {\n      \"enabled\": {\n        \"type\": \"bool\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"state\": {\n        \"type\": \"str\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"id\": {\n        \"type\": \"str\",\n        \"fields\": {},\n        \"methods\": [],\n        \"built-in\": []\n      },\n      \"info\": {\n        \"type\": \"dict\",\n        \"fields\": {\n          \"workers\": {\n            \"type\": \"int\",\n            \"fields\": {},\n            \"methods\": [],\n            \"built-in\": []\n          }\n        },\n        \"methods\": [],\n        \"built-in\": [\"__getitem__\"]\n      }\n    },\n    \"methods\": [\"is_trivial_worker\", \"get_tasks\"],\n    \"built-in\": []\n  },\n  \"kwargs\": {\n    \"type\": \"dict\",\n    \"fields\": {},\n    \"methods\": [],\n    \"built-in\": [\"__getitem__\", \"__setitem__\"]\n  }\n}\n```"}
